## 动态规划问题总结
### 普通问题
- 背包问题为动态规划问题的基础问题
  - 0 - 1 背包为无重复 横向互不影响的问题
  - 完全背包横向之间是有影响的
  - 多重背包转换为0 - 1背包
  - **重点是，明确正向枚举和反向枚举的关系**
  - 一般而言，DP由子问题已经求得的最优解出发
  - 正向枚举时会导致子问题被重用，横向相互影响，这就是完全背包模型
  - 反向则横向单次循环是独立的
- 背包问题的核心是：
  - **如何进行状态转移的建模**
  - **如何分解子问题**
- 其中涉及到一些处理上的技巧，比如
  - 合法性设定（精巧）
  - 空间优化（我们的讨论核心：大规模DP问题将会导致巨量的时间与内存消耗）
  - 前驱表的设定
  - 计数问题：隐式的乘法 / 加法法则
  - 能够运用上面的技巧，建立一个正确的状态转移，将会是动态规划基本问题解决的关键
### 论文中的DP
- 以 `GPU Accelerated Real-time Stixel Computation` 为例
- 基本思想就是，在划分前 x 个像素时，使用前 x - 1 个像素划分的子问题的解
- 子问题的解结构已经不会再改变了，因为他们不会被重算
- 需要计算的是
  1. data term for x，x 根据自己本身的性质最适合划分为哪一类？
  2. smooth term for x，x 划分到哪一个stixel以及哪一类符合先验的规则（比如平滑连接，stixel深度连续，物理规则）
  3. 求一个最小化的匹配cost
  4. 注意，虽然子问题的解不会改变，但是我们存有巨量的子问题结果，不同的子问题划分都是不一样的
  5. 我们需要从子问题中，找到最适合当前新加入的x像素的划分
  6. 这就涉及到LUT的建立以及从LUT中求最小规划的问题
  7. 背包问题的LUT就是total这个array
- 论文的问题中，每一列是一个总的子问题，那么存在 w / s列（个子问题）
- 每一列中还有更加细分的子问题，根据划分位置以及每一点给出的深度差异有关
- 现在知道为什么要integer(disparity)了吧？
- 非整数的disparity根本没办法存，更不要说根据disparity子问题求最优的disparity划分了