#!/usr/bin/env python3
#-coding:utf-8-*-
# 匈牙利算法
# 又是一个理解起来及其简单
# 非递归实现不是很简单的算法
# 递归算法其实也不是很好想

import numpy as np

def match(pos, adjs, V2, checked):
    for i in range(len(V2)):
        if adjs[pos][i] and not checked[i]:
            # 意思是：本次查找时，pos结点（V1）存在连边的V2中结点 i
            # 如果 i 之前没有被查找过，才能对i进行查找
            # 因为如果没有此限制，递归无法停止
            checked[i] = True
            # 如果V2结点i没有被匹配，或者是，能够通过进一步匹配将原本已经匹配的i结点更换位置
            # 那么说明可以通过某些操作可以使pos, i两个结点都能存在对应的匹配
            # 重新给V2[i] 找匹配项，这里为什么可以这样做呢？
            # 因为若是某两个点已经匹配了
            # 比如x 与 y分别为 V1, V2 两个点集中的点
            # 当此处x 选择与 i 进行匹配，造成y需要重选时，y无法再选i 因为已经是 checked 
            # 因此 y 只能选别的点，这样递归下去就是查找，之前匹配是否能拆开
            # 找到别的匹配，给新加入的点让出匹配位置
            if V2[i] == -1 or match(V2[i], adjs, V2, checked):
                V2[i] = pos
                return True     # 找到了（回溯）直接返回
    return False                # 直到最后都无法匹配

def runHungary(len_v1, len_v2, adjs):
    V1 = [False for i in range(len_v1)]
    V2 = [-1 for i in range(len_v2)]        # 表示匹配前驱项
    for i in range(len_v1):
        # 在匹配每一个 v1 中的结点时，都设置：V2中的结点没有被查找过
        # 原因是：如果没有被查找过，而之前的匹配V2又实际存在
        # 那么说明，这个匹配是可以拆开的
        # 后进结点总有机会拆开之前的匹配
        chk = [False for i in range(len_v2)]
        if match(i, adjs, V2, chk):
            V1[i] = True
    return V1, V2          # v1 为v1中结点师傅成功匹配，v2为与v2中每一个结点匹配的结果

## 以上其实是一个回溯法的例子，本次更改可能会导致之前的结果产生冲突
## 那么修改之前的冲突又可能使更前的结果冲突，也需要修改，直到全部修改或者不能进行此次修改的命令返回为止
## 回溯法将成为算法方面的下一个重点
## 非常重要，回溯与剪枝。

# 通过 matches 得到邻接矩阵
def getAdjs(matches, x, y):
    adjs = np.zeros((x, y)).astype(int)
    for match in matches:
        i, j = match
        adjs[i][j] = 1
    print(adjs)
    return adjs
    
if __name__ == "__main__":
    matches = [
        (0, 1), (1, 0), (1, 1), (1, 2), (2, 2), (2, 4), (3, 2), (3, 3), (4, 3)
    ]
    x, y = 5, 5
    adjs = getAdjs(matches, x, y)

    V1, V2 = runHungary(x, y, adjs)

    print("V1 - V2 matches:")
    for i in range(x):
        print("%d: (%d) --- %d"%(V2[i], V1[i], i))

## 以上结果是正确的，我们从中得到了什么启示呢？（虽然是递归实现的）
## 回溯法的特征基本上都是：最新的进展可能会修改之前的操作
## 回想一下八皇后，越往后的列，越容易出现无法找到对应位置的情况
## 但是后列有办法修改前列已经处理完的结果
## 发现问题就否定之前的结果 --- 回溯到上一个正确的位置
## 这里的实现也是差不多的，重点在两个地方
# 1. 新加入的结点可以修改之前的结果：也就是外层循环中，每循环一次
## 可以访问的表checked都全部置为False一次
## 而在最外层处理单个点的内部（递归进行中），只能对应更改一次每个V2结点的匹配
# 2. 递归实现：是否能匹配取决于目标点当前是否存在匹配 或是 回溯后能不能产生可匹配的位置
## 实现了这些算法，可以看出，这些算法都是讨论加入一个新元素，新元素本身对之前的cost或是匹配的影响
## DP 中则是分割子问题，大规模问题的计算最后会归结为小规模问题之前计算的结果
## 而回溯法则是：之前的计算依赖于之后的计算正确性
## 这个总结起来就是：先前的元素匹配成功的机会更多，但是可能被后来的元素修改
## 后来的元素可以修改先前的元素匹配结果，但是最终无法匹配的概率也更大

    

